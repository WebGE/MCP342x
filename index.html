<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="description" content="Amplifier et convertir une grandeur analogique : Programmes de test en C# et description de la classe MCP342x destinée aux cartes Netduino et FezPanda">
  <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
  <title>MCP342x</title>
</head>

<body>
  <!-- HEADER -->
  <div id="header_wrap" class="outer">
    <header class="inner">
      <a id="forkme_banner" href="https://github.com/WebGE/MCP342x">View on GitHub</a>

      <h1 id="project_title">18-Bit, Multi-Channel ΔΣ Analog-to-Digital Converter (I²C)</h1>
      <h2 id="project_tagline">Description de la classe <strong><em>MCP342x</em></strong> développée en C# sous .NETMF 4.3 pour les cartes Netduino
        et FEZ (PANDA, COBRA...)</h2>

      <section id="downloads">
        <a class="zip_download_link" href="https://github.com/WebGE/TMP102/zipball/master">Download this project as a .zip file</a>
        <a class="tar_download_link" href="https://github.com/WebGE/TMP102/tarball/master">Download this project as a tar.gz file</a>
      </section>
    </header>
  </div>

  <!-- MAIN CONTENT -->
  <div id="main_content_wrap" class="outer">
    <section id="main_content" class="inner">
      <hr>
      <h4>Sommaire</h4>
      <ol>
        <li>LE MATERIEL
          <ol>
            <li>Le circuit 342x: 18-Bit, Multi-Channel ΔΣ Analog-to-Digital Converter with I2C Interface and On-Board Reference</li>
            <li><a href="#DUINO">Les cartes Netduino</a></li>
            <li><a href="#FEZ">Les cartes FEZ</a> </li>
          </ol>
        </li>
        <li><a href="#LOG">LE LOGICIEL</a>
          <ol>
            <li><a href="#REP">Contenu du répertoire proposé au téléchargement</a></li>
            <li><a href="#NUGET">Le NuGet MicroToolsKit</a></li>
            <li><a href="#WIKI">Les Wikis</a></li>
            <li><a href="#DESC">Description et utilisation de la classe MCP342x</a></li>
          </ol>
        </li>
      </ol>
      <hr>
      <h3>1. LE MATERIEL</h3>
      <hr>
      <h4>1.1 Le circuit 342x: 18-Bit, Multi-Channel ΔΣ Analog-to-Digital Converter with I2C Interface and On-Board Reference.</h4>
      <hr>
      <ul>
        <li><strong>Présentation</strong></li>
        <p>Les circuits MCP3422, MCP3423 et MCP3424 sont des convertisseurs analogique numérique 18 bit sigma-delta précis et à faible bruit.
        </p>
        <li><strong>Schéma interne du composant</strong></li>
        <p align="center"><img src="images/mcp342x.png" width="70%" height="70%"></p>
        <li><strong>Adressage</strong></li>
        <p align="center"><img src="images/AdressageMCP342x.png" width="50%" height="50%"></p>
        <li><strong>Influence de la résolution sur le débit binaire</strong></li>
        <p align="center">
          <img src="images/data rate.png" width="50% " height="50% "></p>
        <li><strong>Documentation: </strong><a href="datasheets/MCP342x.pdf" target="_blank">pdf</a></li>
        <li><strong>Distributeur: </strong>
          <a href="http://www.gotronic.fr/art-module-4-canaux-analogiques-i2c-dfr0316-22402.htm" target="_blank">Go Tronic</a>
        </li>
      </ul>
      <h4>Module 4 canaux analogiques I2C DFR0316</h4>
      <hr>
      <table width="100% ">
        <tr align="center">
          <td><strong>DFROBOT</strong></td>
        </tr>
        <tr align="center">
          <td><img src="images/dfr0316.png"></td>
        </tr>
        <tr align="center">
          <td><a href="https://www.dfrobot.com/wiki/index.php/MCP3424_18-Bit_ADC-4_Channel_with_Programmable_Gain_Amplifier_(SKU:DFR0316)" target="_blank">Documentation</a> -
            <a href="datasheets/DFR0316_V1.0_Schematic.PDF">Schéma</a>
          </td>
        </tr>
      </table>
      <hr>

      <h4 id="DUINO">1.2 Les cartes Netduino</h4>
      <h5>Secret Labs</h5>
      <hr>
      <ul>
        <li><strong>Microcontrôleur</strong> : STM32F405RG 32 bits à architecture Cortex-M4 cadencé à 168 MHz.</li>
        <li><strong>RAM</strong> : 164KB+.</li>
        <li><strong>Flash</strong> : 1408KB.</li>
        <li><strong>Port Ethernet : </strong> 10/100Mbps (Wifi:802.11b/g/n)*.</li>
        <li><strong>E/S numériques</strong> : 22</li>
        <li><strong>Entrées analogiques</strong> : 6</li>
        <li><strong>Stockage</strong>: carte µSD</li>
        <li><strong>IDE</strong> : Microsoft Visual Studio</li>
        <li><strong>Framework</strong> : .NETMF 4.3</li>
        <li><strong>Langages de programmation</strong> : C#, VB</li>
        <li><strong>Compatibilité</strong> : shield Arduino, Gadgeteer</li>
      </ul>
      <table>
        <tr>
          <td><img src="images/netduino3ethernet.png" alt="Netduino plus 2" target="_blank" /></td>
          <td><img src="images/inputandoutput.png" alt="Netduino 3 wifi" target="_blank" /></td>
        </tr>
        <tr>
          <td align="center"><strong>Netduino 3 Ethernet</strong></td>
          <td align="center"><strong>Netduino 3 wifi*</strong></td>
        </tr>
      </table>
      <ul>
        <li><strong>Sites à consulter</strong> : <a href="http://netduino.com/netduinoplus2/specs.htm" target="_blank">Netduino</a>,
          <a href="http://www.netmf.com/" target="_blank">NETMF</a></li>
        <li><strong>Distributeurs</strong> :
          <a href="http://www.mouser.fr/Search/Refine.aspx?Keyword=netduino" target="_blank">Mouser Electronics</a>
        </li>
      </ul>
      <hr>

      <h4 id="FEZ">1.3 Les cartes FEZ</h4>
      <h5>GHI Electonics (Extrait)</h5>
      <hr>
      <ul>
        <li><strong>Microcontrôleur</strong> : 180 MHz 32-bit ARM Cortex-M4.(120 MHz 32-bit ARM Cortex-M3 )*</li>
        <li><strong>SoC(SoM)*</strong> : <a href="https://www.ghielectronics.com/catalog/product/501" target="_blank">G80</a>
          <a href="https://www.ghielectronics.com/catalog/product/373" target="_blank">G120*</a>
        </li>
        <li><strong>RAM</strong> : 156 KB(2.87 MB)*.</li>
        <li><strong>Flash</strong> : 256 KB (13.67 MB)*.</li>
        <li><strong>E/S numériques</strong> : 53(60)*</li>
        <li><strong>Entrées analogiques</strong> : 16(8)*</li>
        <li><strong>Réseaux : </strong> Ethernet TCP/IP, WiFi, and SSL.</li>
        <li><strong>Stockage</strong>: carte µSD</li>
        <li><strong>IDE</strong> : Microsoft Visual Studio</li>
        <li><strong>Framework</strong> : .NETMF 4.3</li>
        <li><strong>Langages de programmation</strong> : C#, VB</li>
      </ul>

      <table>
        <tr>
          <td><img src="images/panda3.png " alt="PANDA III" /></td>
          <td><img src="images/cobra3.png " alt="COBRA III" /></td>
        </tr>
        <tr>
          <td align="center"><strong>PANDA III</strong></td>
          <td align="center"><strong>COBRA III* (compatible Gadgeteer)</strong></td>
        </tr>
      </table>

      <ul>
        <li><strong>Sites à consulter</strong> : <a href="https://www.ghielectronics.com/" target="_blank">GHI ELECTRONICS</a>,
          <a href="http://www.netmf.com/" target="_blank">NETMF</a></li>
        <li><strong>Distributeurs</strong> : <a href="http://www.mouser.fr " target="_blank">Mouser Electronics</a></li>
      </ul>

      <hr>
      <h3 id="LOG">2. LE LOGICIEL</h3>
      <hr>

      <h4 id="REP">2.1 Contenu du répertoire proposé au téléchargement</h4>
      <hr>
      <p>Le répertoire proposé au téléchargement (au format zip ou tar.gz) contient la solution <strong>MCP342x</strong>        composée :
      </p>
      <ul>
        <li>Du projet <strong>MCP342x </strong>: le <strong>code source</strong> de la classe <em>MCP342x</em>.</li>
        <li>Du projet <strong>Netduino </strong>: un exemple d'utilisation de cette classe avec une carte Netduino.</li>
				<li>Du projet <strong>FezPanda </strong>: un exemple d'utilisation de cette classe avec une carte Fez Panda.</li>
      </ul>
      <hr>

      <h4 id="NUGET">2.2 Le NuGet MicroToolsKit</h4>
      <p>La dernière version <strong>compilée</strong> de la classe <strong>MCP342x</strong> se situe dans la bibliothèque
        <strong>MicroToolsKit</strong> disponible sur <a href="https://www.nuget.org/packages/WebGE.MicroToolsKit/ " target="_blank">nuget.org</a>.</p>
      <p align="center"><img src="images/NuGet-large.png" /></p>
      <p><strong>Organisation des classes</strong> contenues dans MicroToolsKit
        <a href="https://csharpembarquenetduino.wikispaces.com/6.+La+biblioth%C3%A8que+MicroToolsKit" target="_blank">[lien]</a>
      </p>
      <p><em>Installer cette bibliothèque dans le projet simplifie l'utilisation de cette classe.</em></p>
      <hr>

      <h4 id="WIKI">2.3 Les Wikis</h4>
      <ul>
        <li><strong>Fascicules</strong> d'exemples de code pour les cartes <strong>Netduino</strong>.
          <a href="https://csharpembarquenetduino.wikispaces.com/5.+Les+fascicules+d%27exemples+cod%C3%A9s+en+CSharp " target="_blank">[lien]</a>
        </li>
        <li><strong>Fascicule</strong> d'exemples de code pour les cartes <strong>FEZ</strong>.
          <a href="https://csharpembarquefez.wikispaces.com/5.+Les+fascicules+d%27exemples+cod%C3%A9s+en+CSharp " target="_blank">[lien]</a>
        </li>
      </ul>
      <hr>

      <h4 id="DESC">2.4 Description et utilisation de la classeMCP342x</h4>
      <ul>
        <li><strong>Rôle: </strong>Contrôler un capteur de température à infrarouges MCP342x via un bus I²C.</li>
        <li><strong>Assembly: </strong> <em>MicroToolsKit</em> (disponible sur
          <a href="https://www.nuget.org/packages/WebGE.MicroToolsKit/" target="_blank">nuget.org</a>)</li>
        <li><strong>Espace de noms: </strong><em>Microtoolskit.Hardware.IO</em></li>
      </ul>
      <hr>

      <p><strong>Création d'un projet avec l'IDE Visual Studio</strong></p>
      <hr>
      <ol>
        <li><strong>Créer </strong>un nouveau projet en suivant la démarche décrite dans le chapitre <em>"Premier programme en C# étape par étape"</em>					du Wiki dédié à une carte <strong>Netduino</strong> ou du Wiki dédié à une carte <strong>Fez. </strong>Ces Wikis sont
					accessibles
					<a href="https://csharpembarquenetduino.wikispaces.com/6.+MicroToolsKit+library" target="_blank">ici</a>.</li>
				<li><strong>Utiliser</strong> le gestionnaire de paquets NuGet pour <strong>ajouter</strong> la bibliothèque <strong>MicroToolsKit</strong>					(
					<a href="https://www.nuget.org/packages/WebGE.MicroToolsKit/ " target="_blank ">nuget.org</a>) dans le projet. (Dans
					l'explorateur de solution, clic droit sur les <em>Références</em> du projet puis choisir <em>Gérer les packages NuGet...</em>.<strong> Installer</strong>					le paquet.)</li>
        <li><strong>Ajouter</strong> l'espace de noms <strong>Microtoolskit.Hardware.Sensors</strong> dans l'en-tête du fichier
          source.
        </li>
        <li><strong>Créer</strong> un objet en utilisant le constructeur <em>MCP342x</em>.</li>
        <li><strong>Utiliser</strong> la méthode <strong>ReadVolts</strong> pour déclencher une mesure de la tension sur l'une des entrées du convertisseur analogique numérique.</li>
      </ol>
      <hr>
      <p><strong>Exemple</strong></p>
      <pre>
namespace test
{
  public class Program
  {
    public static void Main() 
    {
      MCP342x can = new MCP342x();

      while(true)
      { 
        byte j = 0;
        double resolution = Resolution(can.Resolution);
        double gain = System.Math.Pow(2, (byte)can.Gain);
        Debug.Print("Continuous on channel " + j + " =>Tension= " + can.ReadVolts().ToString("F2") + "   " + "Resol: " + resolution + "-bit " + "Gain: " + gain);
        Thread.Sleep(1000);
        } 
      }
   }
}
      </pre>
      <hr>

      <p><strong>Constructeurs</strong></p>
      <table width="100%">
        <tr>
          <td></td>
          <td><strong>Syntaxe</strong></td>
          <td><strong>Description</strong></td>
        </tr>
        <tr>
          <td><img src="images/Method_16x.png"></td>
          <td><strong>TMP102</strong>(<strong>ADD0</strong> <em>pin</em>, <strong>UInt16</strong> <em>Frequency</em> )</td>
          <td>Instancie un objet "TMP102 ". <br><strong>pin : </strong> égal à ADD0.GND =><strong>SLA</strong>= 0x48. (par défaut)<br>
            <strong>Frequency: </strong>>Féquence du signal SCL = 100kHz. (par défaut)<br><br>
            <strong>Exemple</strong><br>
            <em>TMP102 ModuleMesureTemp = new TMP102();</em>
          </td>
        </tr>
      </table>

      <p><strong>Enumérations</strong></p>
      <table width="100%">
        <tr>
          <td></td>
          <td><strong>Syntaxe</strong></td>
          <td><strong>Description</strong></td>
        </tr>
        <tr>
          <td><img src="images/Enumerator_16x.png"></td>
          <td><strong>ADD0</strong></td>
          <td>
            <p>Si la broche ADD0 est connecté à :</p>
            <ul>
              <li><strong>GND</strong> : adresse <strong>SLA </strong>= 0x48</li>
              <li><strong>Vcc</strong> : adresse <strong>SLA </strong>= 0x49</li>
              <li><strong>SDA</strong> : adresse <strong>SLA </strong>= 0x4A</li>
              <li><strong>SCL</strong> : adresse <strong>SLA </strong>= 0x4B</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><img src="images/Enumerator_16x.png"></td>
          <td><strong>AlertPolarity</strong></td>
          <td>
            <p>AlertPolarity permet de régler l'état actif de la broche ALERT.</p>
            <ul>
              <li><strong>activeLow</strong> : broche active à l'état BAS</li>
              <li><strong>activeHight</strong> : broche active à l'état HAUT</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><img src="images/Enumerator_16x.png"></td>
          <td><strong>ConsecutiveFaults</strong></td>
          <td>
            <p>Une erreur se produit lorsque la température dépasse les limites fixées par l'utilisateur dans les registres
              THIGH et TLOW. <em>ConsecutiveFaults</em> active la broche ALERT si un, deux, quatre ou six dépassements se
              sont produits.
            </p>
            <ul>
              <li><strong>one</strong></li>
              <li><strong>two</strong></li>
              <li><strong>four</strong></li>
              <li><strong>six</strong></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><img src="images/Enumerator_16x.png"></td>
          <td><strong>ConversionRate</strong></td>
          <td>
            <p>Fréquence de conversion </p>
            <ul>
              <li><strong>quarter_Hz</strong> : une mesure toutes les quatre secondes</li>
              <li><strong>one_Hz</strong> : une mesure par seconde</li>
              <li><strong>four_Hz</strong> : quatre mesures par seconde (par defaut)</li>
              <li><strong>height_Hz</strong> : huit mesures par seconde</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><img src="images/Enumerator_16x.png"></td>
          <td><strong>Registers</strong></td>
          <td>
            <p>Sélection des registres du TMP102</p>
            <ul>
              <li><strong>Temperature</strong> : contient la valeur de la température sur 12bits (par défaut). (lecture)</li>
              <li><strong>Configuration</strong> : Paramétrage du TMP102 (lecture/évriture)</li>
              <li><strong>T_Low</strong>: Contient la valeur limite basse de la température</li>
              <li><strong>T_High</strong> : Contient la valeur limite haute de la température</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><img src="images/Enumerator_16x.png"></td>
          <td><strong>ThermostatMode</strong></td>
          <td>
            <p></p>
            <ul>
              <li><strong>ComparatorMode</strong> : En mode comparateur, la broche ALERT devient active lorsque la température
                est égale ou supérieure à la valeur mémorisée dans T_HIGH et génère un nombre consécutif de défauts en accord
                avec <em>ConsecutiveFaults</em> La broche ALERT reste active jusqu'à ce que la température soit inférieure
                à la valeur mémorisée dans T_LOW et que le même nombre de défauts est atteint.</li>
              <li><strong>InterruptMode</strong> : en mode interruption, la broche ALERT devient active quand le nombre d'erreurs
                est atteint... (voir le datasheet pour plus d'informations)
              </li>
            </ul>
          </td>
        </tr>
      </table>

      <p><strong>Méthodes</strong></p>
      <table width="100%">
        <tr>
          <td></td>
          <td><strong>Syntaxe</strong></td>
          <td><strong>Description</strong></td>
        </tr>
        <tr>
          <td><img src="images/Method_16x.png"></td>
          <td><strong>bool</strong> Init(<strong>ADD0 </strong><em>addressSelect</em>)</strong>
          </td>
          <td>
            <p>Initialise le composant avec :</p>
            <ul>
              <li><strong>addressSelect</strong> : A paramétrer, = ADD0.Gnd (par défaut)</li>
              <li><strong>oneShotMode</strong> = false (par défaut)</li>
              <li><strong>alertPolarity</strong> = AlertPolarity.activeHight (par défaut)</li>
              <li><strong>conversionRate</strong> = ConversionRate.four_Hz (par défaut)</li>
              <li><strong>thermostatMode</strong> = ThermostatMode.ComparatorMode (par défaut)</li>
            </ul>
            <br>
            <strong>Exemple</strong><br>
            <em>ModuleMesureTemp.Init();</em>
          </td>
        </tr>
        <tr>
          <td><img src="images/Method_16x.png"></td>
          <td><strong>bool</strong> Init(<br> [
            <strong>ADD0</strong> <em>addressSelect = ADD0.Gnd</em> ],<br> [
            <strong>bool</strong> <em>oneShotMode = false</em> ],<br> [
            <strong>AlertPolarity</strong> <em>alertPolarity = AlertPolarity.activeHight</em> ],<br> [
            <strong>ConversionRate</strong> <em>conversionRate = ConversionRate.four_Hz</em> ], <br> [
            <strong>ThermostatMode</strong> <em>thermostatMode = ThermostatMode.ComparatorMode</em> ])
          </td>
          <td>
            <p>Initialise le composant avec :</p>
            <ul>
              <li><strong>addressSelect</strong> : A paramétrer, égale à ADD0.Gnd (par défaut) </li>
              <li><strong>oneShotMode</strong> : A paramétrer, égal à false (par défaut)</li>
              <li><strong>alertPolarity</strong> : A paramétrer, égale à AlertPolarity.activeHight (par défaut)</li>
              <li><strong>conversionRate</strong> : A paramétrer, égale à ConversionRate.four_Hz (par défaut)</li>
              <li><strong>thermostatMode</strong> : A paramétrer, égal à ThermostatMode.ComparatorMode (par défaut</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><img src="images/Method_16x.png"></td>
          <td><strong>float ReadAsCelcius()</strong></td>
          <td>Renvoi la température de l'air en °C.<br><br>
            <strong>Exemple</strong><br>
            <em>temperature = ModuleMesureTemp.ReadAsCelcius();</em>
          </td>
        </tr>
        <tr>
          <td><img src="images/Method_16x.png"></td>
          <td><strong>float ReadAsFahrenheit()</strong></td>
          <td>Renvoi la température de l'air en °F.
            <br><br>
            <strong>Exemple</strong><br>
            <em>temperature = ModuleMesureTemp.ReadAsFahrenheit();</em>
          </td>
        </tr>
        <tr>
          <td><img src="images/Method_16x.png"></td>
          <td><strong>float ReadAsKelvin()</strong></td>
          <td>Renvoi la température de l'air en K.
            <br><br>
            <strong>Exemple</strong><br>
            <em>temperature = ModuleMesureTemp.ReadAsKelvin();</em>
          </td>
        </tr>
        <tr>
          <td><img src="images/Method_16x.png"></td>
          <td><strong>float ReadAsRankine()</strong></td>
          <td>Renvoi la température de l'air en °R.
            <br><br>
            <strong>Exemple</strong><br>
            <em>temperature = ModuleMesureTemp.ReadAsRankine();</em>
          </td>
        </tr>
      </table>
    </section>
  </div>

  <!-- FOOTER  -->
  <div id="footer_wrap" class="outer">
    <footer class="inner ">
      <p class="copyright">Description de la classe <strong><em>TMP102</em></strong> développée en C# sous .NETMF 4.3 pour les cartes Netduino
        et FEZ (PANDA, COBRA...) maintained by <a href="https://github.com/WebGE">WebGE</a></p>
      <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
    </footer>
  </div>



</body>

</html>